"""
Algorithm 6 (A6): Deformation / Displacement Measurement

This script computes displacement using the homography results produced by A5.
A6 starts from grid alignment (align_points_to_grid) and then performs:
- post-homography baseline alignment
- scale update (um-per-pixel) based on aligned baseline
- per-frame reference drift compensation (using ref_data)
- per-frame homography projection + alignment
- displacement calculation relative to baseline

Inputs:
- pkl_dir: directory containing PKL files with keys {"data", "ref_data"}
- homography_params.pkl: output from A5

Outputs:
- CSV (and optionally PKL) containing mean displacement per frame
"""

from __future__ import annotations

import os
import pickle
import argparse
import logging
import numpy as np
import pandas as pd

# ---- Project-specific imports (adjust paths if needed) ----
from lib.L1_Image_Conversion import *
from lib.L2_Point_Detection_Conversion import *
from lib.L3_Zhang_Camera_Calibration import *
from lib.L4_Pipeline_Utilities import *
from lib.L5_Visualization_Utilities import *


def compute_displacement_using_homography(
    pkl_dir: str,
    homography_pkl_path: str,
    y_threshold_align: float = 50.0,
    x_threshold_align: float = 50.0,
) -> pd.DataFrame:
    """Compute per-frame displacement (A6 starts at align_points_to_grid)."""
    with open(homography_pkl_path, "rb") as f:
        H_payload = pickle.load(f)

    H = np.asarray(H_payload["H"], dtype=float)
    ref0 = np.asarray(H_payload["ref0"], dtype=float)
    data0_h = np.asarray(H_payload["data0_h"], dtype=float)

    grid_rows = int(H_payload["grid_rows"])
    grid_cols = int(H_payload["grid_cols"])

    # A6 begins: baseline alignment
    data0_h = align_points_to_grid(
        data0_h, grid_rows, grid_cols, y_threshold_align, x_threshold_align
    )
    data0_h = np.asarray(data0_h, dtype=float)

    # Scale update after H + align (your logic)
    avg_dist_px0_h, _ = how_much_rect(pd.DataFrame(data0_h), grid_rows, grid_cols)
    um_per_pixel = (6.0 * 1000.0) / avg_dist_px0_h

    pkl_files = [f for f in os.listdir(pkl_dir) if f.lower().endswith(".pkl")]
    pkl_files.sort(key=natural_key)
    if not pkl_files:
        raise RuntimeError(f"No PKL found in: {pkl_dir}")

    records = []
    for order, fname in enumerate(pkl_files):
        with open(os.path.join(pkl_dir, fname), "rb") as f:
            payload = pickle.load(f)

        data = ensure_2col(payload.get("data"))
        ref = ensure_2col(payload.get("ref_data"))
        if data is None or ref is None:
            logging.warning(f"[A6] skip invalid: {fname}")
            continue

        data = np.asarray(data, dtype=float)
        ref = np.asarray(ref, dtype=float)

        # drift compensation using ref_data (your logic)
        move = (ref - ref0).mean(axis=0)
        data_corr = data - move

        # homography + alignment
        data_h = apply_homography(H, np.array(data_corr))
        data_h = align_points_to_grid(
            data_h, grid_rows, grid_cols, y_threshold_align, x_threshold_align
        )
        data_h = np.asarray(data_h, dtype=float)

        # displacement relative to baseline
        disp = data_h - data0_h
        disp_um = disp * um_per_pixel

        mean_dx_um, mean_dy_um = np.nanmean(disp_um, axis=0)
        mean_disp_um = float(np.hypot(mean_dx_um, mean_dy_um))

        records.append(
            {
                "order": order,
                "file": fname,
                "mean_dx_um": float(mean_dx_um),
                "mean_dy_um": float(mean_dy_um),
                "mean_disp_um": mean_disp_um,
                "um_per_pixel": float(um_per_pixel),
            }
        )

    return pd.DataFrame(records)


def build_argparser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="A6: Displacement measurement using A5 homography")
    p.add_argument("--pkl_dir", required=True, help="Directory containing PKL files")
    p.add_argument("--homography", required=True, help="Homography params PKL generated by A5")
    p.add_argument("--out_csv", required=True, help="Output CSV path")
    p.add_argument("--y_thr", type=float, default=50.0)
    p.add_argument("--x_thr", type=float, default=50.0)
    return p


if __name__ == "__main__":
    args = build_argparser().parse_args()

    df = compute_displacement_using_homography(
        pkl_dir=args.pkl_dir,
        homography_pkl_path=args.homography,
        y_threshold_align=args.y_thr,
        x_threshold_align=args.x_thr,
    )

    os.makedirs(os.path.dirname(args.out_csv), exist_ok=True)
    df.to_csv(args.out_csv, index=False)
    print(f"âœ… Saved displacement results: {args.out_csv}")
